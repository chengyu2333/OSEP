/*
This is the Scratch 3 extension to remotely control an
Arduino Uno, ESP-8666, or Raspberry Pi


 Copyright (c) 2019 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

// Boiler plate from the Scratch Team
const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const formatMessage = require('format-message');

require('sweetalert');

// The following are constants used within the extension

// Digital Modes
const DIGITAL_INPUT = 1;
const DIGITAL_OUTPUT = 2;
const PWM = 3;
const SERVO = 4;
const TONE = 5;
const SONAR = 6;
const ANALOG_INPUT = 7;


// an array to save the current pin mode
// this is common to all board types since it contains enough
// entries for all the boards.
// Modes are listed above - initialize to invalid mode of -1
let pin_modes = new Array(30).fill(-1);

// has an websocket message already been received
let alerted = false;

let connection_pending = false;

// general outgoing websocket message holder
let msg = null;

// the pin assigned to the sonar trigger
// initially set to -1, an illegal value
let sonar_report_pin = -1;

// flag to indicate if the user connected to a board
let connected = false;

// arrays to hold input values
let digital_inputs = new Array(32);
let analog_inputs = new Array(8);

// flag to indicate if a websocket connect was
// ever attempted.
let connect_attempt = false;

// an array to buffer operations until socket is opened
let wait_open = [];

let the_locale = null;

// common

const FormDigitalWrite = {
    'pt-br': 'Definir Pino Digital[PIN]como[ON_OFF]',
    'pt': 'Definir Pino Digital[PIN]como[ON_OFF]',
    'en': 'Write Digital Pin [PIN] [ON_OFF]',
    'fr': 'Mettre la pin numérique[PIN]à[ON_OFF]',
    'zh-tw': '腳位[PIN]數位輸出[ON_OFF]',
    'zh-cn': '脚位[PIN]数位输出[ON_OFF]',
};

const FormPwmWrite = {
    'pt-br': 'Definir Pino PWM[PIN]com[VALUE]%',
    'pt': 'Definir Pino PWM[PIN]com[VALUE]%',
    'en': 'Write PWM Pin [PIN] [VALUE]%',
    'fr': 'Mettre la pin PWM[PIN]à[VALUE]%',
    'zh-tw': '腳位[PIN]類比輸出[VALUE]%',
    'zh-cn': '脚位[PIN]类比输出[VALUE]%',
};

const FormTone = {
    'pt-br': 'Definir Buzzer no Pino[PIN]com[FREQ]Hz e[DURATION]ms',
    'pt': 'Definir Buzzer no Pino[PIN]com[FREQ]Hz  e[DURATION]ms',
    'en': 'Tone Pin [PIN] [FREQ] Hz [DURATION] ms',
    'fr': 'Définir le buzzer sur la pin[PIN]à[FREQ]Hz pendant[DURATION] ms',
    'zh-tw': '腳位[PIN]播放音調，頻率為[FREQ]時間為[DURATION]',
    'zh-cn': '脚位[PIN]播放音调，频率为[FREQ]时间为[DURATION]',
};

const FormServo = {
    'pt-br': 'Mover Servo Motor no[PIN]para[ANGLE]°',
    'pt': 'Mover Servo Motor no[PIN]para[ANGLE]°',
    'en': 'Write Servo Pin [PIN] [ANGLE] Deg.',
    'fr': 'Mettre le servo[PIN]à[ANGLE] Deg.',
    'zh-tw': '伺服馬達腳位[PIN]轉動角度到[ANGLE]度',
    'zh-cn': '伺服马达脚位[PIN]转动角度到[ANGLE]度',

};

const FormAnalogRead = {
    'pt-br': 'Ler Pino Analógico [PIN]',
    'pt': 'Ler Pino Analógico [PIN]',
    'en': 'Read Analog Pin [PIN]',
    'fr': 'Lecture analogique [PIN]',
    'zh-tw': '讀取類比腳位[PIN]',
    'zh-cn': '读取类比脚位[PIN]',

};

const FormDigitalRead = {
    'pt-br': 'Ler Pino Digital [PIN]',
    'pt': 'Ler Pino Digital [PIN]',
    'en': 'Read Digital Pin [PIN]',
    'fr': 'Lecture numérique [PIN]',
    'zh-tw': '讀取數位腳位[PIN]',
    'zh-cn': '读取数位脚位[PIN]',
};

const FormSonarRead = {
    'pt-br': 'Ler Distância: Sonar em T[TRIGGER_PIN] E[ECHO_PIN]',
    'pt': 'Ler Distância: Sonar em T[TRIGGER_PIN] E[ECHO_PIN]',
    'en': 'Read SONAR  T [TRIGGER_PIN]  E [ECHO_PIN]',
    'fr': 'Distance de lecture : Sonar T [TRIGGER_PIN] E [ECHO_PIN]',
    'zh-tw': 'HCSR超音波感測器，Echo在腳位[ECHO_PIN]Trig在腳位[TRIGGER_PIN]',
    'zh-cn': 'HCSR超音波感测器，Echo在脚位[ECHO_PIN]Trig在脚位[TRIGGER_PIN]',
};

// ESP-8266 specific

const FormIPBlockE = {
    'pt-br': 'Endereço IP da placa ESP-8266 [IP_ADDR]',
    'pt': 'Endereço IP da placa ESP-8266 [IP_ADDR]',
    'en': 'ESP-8266 IP Address [IP_ADDR]',
    'fr': "Adresse IP de l'ESP-8266 [IP_ADDR]",
    'zh-tw': 'ESP-8266 IP 位址[IP_ADDR]',
    'zh-cn': 'ESP-8266 IP 地址[IP_ADDR]',
};


// Raspbery Pi Specific
const FormIPBlockR = {
    'pt-br': 'Endereço IP do RPi [IP_ADDR]',
    'pt': 'Endereço IP do RPi [IP_ADDR]',
    'en': 'Remote IP Address [IP_ADDR]',
    'fr': 'Adresse IP du RPi [IP_ADDR]',
    'zh-tw': '遠端 IP 位址[IP_ADDR]',
    'zh-cn': '远程 IP 地址[IP_ADDR]',
};

// General Alert
const FormWSClosed = {
    'pt-br': "A Conexão do WebSocket está Fechada",
    'pt': "A Conexão do WebSocket está Fechada",
    'en': "WebSocket Connection Is Closed.",
    'fr': "La connexion WebSocket est fermée.",
    'zh-tw': "網路連線中斷",
    'zh-cn': "网絡连线中断",
};

// ESP-8266 Alert
const FormAlrt = {
    'pt-br': {
        title: "Atenção",
        text: "Informe o endereço IP da placa ESP-8266 no bloco apropriado",
        icon: "info",
    },
    'pt': {
        title: "Atenção",
        text: "Informe o endereço IP da placa ESP-8266 no bloco apropriado",
        icon: "info",
    },
    'en': {
        title: "Reminder",
        text: "Enter the IP Address of the ESP-8266 Into The IP Address Block",
        icon: "info",
    },
    'fr': {
        title: "Attention",
        text: "Entrez l'adresse IP de l'ESP-8266 dans le bloc approprié.",
        icon: "info",
    },
    'zh-tw': {
        title: "提醒",
        text: "請於 IP 位址積木中輸入 ESP-8266 的 IP 位址",
        icon: "資訊",
    },
    'zh-cn': {
        title: "提醒",
        text: "请于 IP 位址积木中输入 ESP-8266 的 IP 地址",
        icon: "资讯",
    },
};

class Scratch3EspOneGPIO {
    constructor(runtime) {
        the_locale = this._setLocale();
        this.runtime = runtime;
    }

    getInfo() {
        the_locale = this._setLocale();
        this.connect();
        swal(FormAlrt[the_locale]);

        return {
            id: 'onegpioEsp',
            color1: '#0C5986',
            color2: '#34B0F7',
            name: 'OneGpio ESP-8266',
            blockIconURI: 'data:image/png;base64,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',
            blocks: [
                {
                    opcode: 'ip_address',
                    blockType: BlockType.COMMAND,
                    //text: 'Write Digital Pin [PIN] [ON_OFF]',
                    text: FormIPBlockE[the_locale],

                    arguments: {
                        IP_ADDR: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '',
                            //menu: "digital_pins"
                        },

                    }
                },
                {
                    opcode: 'digital_write',
                    blockType: BlockType.COMMAND,
                    text: FormDigitalWrite[the_locale],

                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '4',
                            menu: "digital_pins"
                        },
                        ON_OFF: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '0',
                            menu: "on_off"
                        }
                    }
                },
                {
                    opcode: 'pwm_write',
                    blockType: BlockType.COMMAND,
                    text: FormPwmWrite[the_locale],
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '4',
                            menu: 'pwm_pins'
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '50',
                        }
                    }
                },
                '---',
                {
                    opcode: 'tone_on',
                    blockType: BlockType.COMMAND,
                    text: FormTone[the_locale],
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '4',
                            menu: 'digital_pins'
                        },
                        FREQ: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 100,
                        },
                        DURATION: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50,
                        }
                    }
                },

                '---',
                {
                    opcode: 'servo',
                    blockType: BlockType.COMMAND,
                    text: FormServo[the_locale],
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '4',
                            menu: 'digital_pins'
                        },
                        ANGLE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 90,
                        },

                    }
                },
                '---',
                {
                    opcode: 'analog_read',
                    blockType: BlockType.REPORTER,
                    text: FormAnalogRead[the_locale],
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '0'
                        },
                    }
                },
                '---',
                {
                    opcode: 'digital_read',
                    blockType: BlockType.REPORTER,
                    text: FormDigitalRead[the_locale],
                    arguments: {
                        PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '2',
                            menu: 'digital_pins'
                        },
                    }
                },
                '---',
                {
                    opcode: 'sonar_read',
                    blockType: BlockType.REPORTER,
                    text: FormSonarRead[the_locale],

            arguments: {
                        TRIGGER_PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '4',
                            menu: 'digital_pins'
                        },
                        ECHO_PIN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '5',
                            menu: 'digital_pins'
                        }
                    }
                },
            ],
            menus: {
                digital_pins: {
                    acceptReporters: true,
                    items: ['4', '5', '12', '13', '14', '15']
                },
                pwm_pins: {
                    acceptReporters: true,
                    items: ['4', '5', '12', '13', '14', '15']
                },

                mode: {
                    acceptReporters: true,
                    items: [{text: "Input", value: '1'}, {text: "Output", value: '2'}]
                },
                on_off: {
                    acceptReporters: true,
                    items: ['0', '1']
                }
            }
        };
    }

    // The block handlers

    // command blocks

    ip_address(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }
        if (!connected) {
            let callbackEntry = [this.ip_address.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            msg = {"command": "ip_address", "address": args['IP_ADDR']};
            msg = JSON.stringify(msg);
            window.sockete.send(msg);
        }
    }

    digital_write(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.digital_write.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pin = args['PIN'];
            pin = parseInt(pin, 10);

            if (pin_modes[pin] !== DIGITAL_OUTPUT) {
                pin_modes[pin] = DIGITAL_OUTPUT;
                msg = {"command": "set_mode_digital_output", "pin": pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            let value = args['ON_OFF'];
            value = parseInt(value, 10);
            msg = {"command": "digital_write", "pin": pin, "value": value};
            msg = JSON.stringify(msg);
            window.sockete.send(msg);
        }
    }

    //pwm
    pwm_write(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.pwm_write.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pin = args['PIN'];
            // maximum value for RPi and Arduino
            let the_max = 255;
            pin = parseInt(pin, 10);

            let value = args['VALUE'];
            value = parseInt(value, 10);

            // calculate the value based on percentage
            value = the_max * (value / 100);
            value = Math.round(value);
            if (pin_modes[pin] !== PWM) {
                pin_modes[pin] = PWM;
                msg = {"command": "set_mode_pwm", "pin": pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            msg = {"command": "pwm_write", "pin": pin, "value": value};
            msg = JSON.stringify(msg);
            window.sockete.send(msg);

        }
    }

    tone_on(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.tone_on.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pin = args['PIN'];
            pin = parseInt(pin, 10);
            let freq = args['FREQ'];
            freq = parseInt(freq, 10);
            let duration = args['DURATION'];
            duration = parseInt(duration, 10);
            // make sure duration maximum is 5 seconds
            if (duration > 5000) {
                duration = 5000;
            }


            if (pin_modes[pin] !== TONE) {
                pin_modes[pin] = TONE;
                msg = {"command": "set_mode_tone", "pin": pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            msg = {"command": "play_tone", "pin": pin, 'freq': freq, 'duration': duration};
            msg = JSON.stringify(msg);
            window.sockete.send(msg);

        }
    }

    // move servo
    servo(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }
        if (!connected) {
            let callbackEntry = [this.servo.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pin = args['PIN'];
            pin = parseInt(pin, 10);
            let angle = args['ANGLE'];
            angle = parseInt(angle, 10);


            if (pin_modes[pin] !== SERVO) {
                pin_modes[pin] = SERVO;
                msg = {"command": "set_mode_servo", "pin": pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            msg = {
                'command': 'servo_position', "pin": pin,
                'position': angle
            };
            msg = JSON.stringify(msg);
            window.sockete.send(msg);

        }
    }

    // reporter blocks
    analog_read(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }
        if (!connected) {
            let callbackEntry = [this.analog_read.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pin = 0;

            if (pin_modes[pin] !== ANALOG_INPUT) {
                pin_modes[pin] = ANALOG_INPUT;
                msg = {"command": "set_mode_analog_input", "pin": pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            return analog_inputs[pin];

        }
    }

    digital_read(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }
        if (!connected) {
            let callbackEntry = [this.digital_read.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pin = args['PIN'];
            pin = parseInt(pin, 10);

            if (pin_modes[pin] !== DIGITAL_INPUT) {
                pin_modes[pin] = DIGITAL_INPUT;
                msg = {"command": "set_mode_digital_input", "pin": pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            return digital_inputs[pin];

        }
    }

    sonar_read(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }
        if (!connected) {
            let callbackEntry = [this.sonar_read.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let trigger_pin = args['TRIGGER_PIN'];
            trigger_pin = parseInt(trigger_pin, 10);
            sonar_report_pin = trigger_pin;
            let echo_pin = args['ECHO_PIN'];
            echo_pin = parseInt(echo_pin, 10);


            if (pin_modes[trigger_pin] !== SONAR) {
                pin_modes[trigger_pin] = SONAR;
                msg = {"command": "set_mode_sonar", "trigger_pin": trigger_pin, "echo_pin": echo_pin};
                msg = JSON.stringify(msg);
                window.sockete.send(msg);
            }
            return digital_inputs[sonar_report_pin];

        }
    }

    _setLocale () {
        let now_locale = '';
        switch (formatMessage.setup().locale){
            case 'pt-br':
            case 'pt':
                now_locale='pt-br';
                break;
            case 'en':
                now_locale='en';
                break;
            case 'fr':
                now_locale='fr';
                break;
            case 'zh-tw':
                now_locale= 'zh-tw';
                break;
            case 'zh-cn':
                now_locale= 'zh-cn';
                break;
            default:
                now_locale='en';
                break;
        }
        return now_locale;
    }

    // end of block handlers

    // helpers
    connect() {
        if (connected) {
            // ignore additional connection attempts
            return;
        } else {
            connect_attempt = true;
            window.sockete = new WebSocket("ws://127.0.0.1:9002");
            msg = JSON.stringify({"id": "to_esp8266_gateway"});
        }


        // websocket event handlers
        window.sockete.onopen = function () {

            digital_inputs.fill(1);
            analog_inputs.fill(0);
            // connection complete
            connected = true;
            connect_attempt = true;
            // the message is built above
            try {
                //ws.send(msg);
                window.sockete.send(msg);

            } catch (err) {
                // ignore this exception
            }
            for (let index = 0; index < wait_open.length; index++) {
                let data = wait_open[index];
                data[0](data[1]);
            }
        };

        window.sockete.onclose = function () {
            digital_inputs.fill(1);
            analog_inputs.fill(0);
            sonar_report_pin = -1;
            pin_modes.fill(-1);

            if (alerted === false) {
                alerted = true;
                alert(FormWSClosed[the_locale]);
            }
            connected = false;
        };

        // reporter messages from the board
        window.sockete.onmessage = function (message) {
            msg = JSON.parse(message.data);
            let report_type = msg["report"];
            let pin = null;
            let value = null;

            // types - digital, analog, sonar
            if (report_type === 'digital_input') {
                pin = msg['pin'];
                pin = parseInt(pin, 10);
                value = msg['value'];
                digital_inputs[pin] = value;
            } else if (report_type === 'analog_input') {
                pin = msg['pin'];
                pin = parseInt(pin, 10);
                value = msg['value'];
                analog_inputs[pin] = value;
            } else if (report_type === 'sonar_data') {
                value = msg['value'];
                digital_inputs[sonar_report_pin] = value;
            }
        };
    }


}

module.exports = Scratch3EspOneGPIO;
