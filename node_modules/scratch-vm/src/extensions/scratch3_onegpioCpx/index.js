/*
This is the Scratch 3 extension to remotely control a
Circuit Playground Express

 Copyright (c) 2020 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

// Boiler plate from the Scratch Team
const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const formatMessage = require('format-message');

require('sweetalert');

// has an websocket message already been received
let alerted = false;

let connection_pending = false;

// general outgoing websocket message holder
let msg = null;

// flag to indicate if the user connected to a board
let connected = false;

// flag to indicate if a websocket connect was
// ever attempted.
let connect_attempt = false;

// an array to buffer operations until socket is opened
let wait_open = [];

let the_locale = null;

// menus
const MENU_LIGHT_TEMPERATURE = {
    'en': ['light', 'temperature'],
    'zh-tw':['光線', '溫度'],
    'zh-cn':['光线', '温度'],
    'pt': ['luminosidade', 'temperatura'],
    'pt-br': ['luminosidade', 'temperatura'],
    'fr': ['lumière', 'température'],
    'pl': ['światło', 'temperatura'],
};

const MENU_PUSH_BUTTONS = {
    'en': ['A', 'B'],
    'zh-tw': ['A', 'B'],
    'zh-cn': ['A', 'B'],
    'pt': ['A', 'B'],
    'pt-br': ['A', 'B'],
    'fr': ['A', 'B'],
    'pl': ['A', 'B'],
};

const MENU_PUSH_BUTTON_STATE = {
    'en': ['pressed', 'released'],
    'zh-tw': ['被按下', '被放開'],
    'zh-cn': ['被按下', '被放开'],
    'pt': ['pressionado', 'liberado'],
    'pt-br': ['pressionado', 'liberado'],
    'fr': ['appuyé', 'relaché'],
    'pl': ["wciśnięty", "zwolniony"],
};

const MENU_SLIDE_SWITCH_POSITION = {
    'en': ['left', 'right'],
    'zh-tw': ['左', '右'],
    'zh-cn': ['左', '右'],
    'pt': ['esquerda', 'direita'],
    'pt-br': ['esquerda', 'direita'],
    'fr': ['gauche', 'droite'],
    'pl': ['lewo', 'prawo'],
};

const MENU_TOUCH_PAD_STATES = {
    'en': ['touched', 'released'],
    'zh-tw': ['被按壓', '被放開'],
    'zh-cn': ['被按压', '被放开'],
    'pt': ['tocado', 'liberado'],
    'pt-br': ['tocado', 'liberado'],
    'fr': ['touché', 'relaché'],
    'pl': ["dotknięty", "zwolniony"],
};

const MENU_TILT_POSITION = {
    'en': ['flat', 'up', 'down', 'left', 'right'],
    'zh-tw': ['放平', '朝上', '朝下', '朝左', '朝右'],
    'zh-cn': ['放平', '朝上', '朝下', '朝左', '朝右'],
    'pt': ['plana', 'para cima', 'para baixo', 'para direita', 'para esquerda'],
    'pt-br': ['plana', 'para cima', 'para baixo', 'para direita', 'para esquerda'],
    'fr': ['horizontale', 'en haut', 'en bas', 'à gauche', 'à droite'],
    'pl': ['płasko', 'w górę', 'w dół', 'w lewo', 'w prawo'],
};

const MENU_BOARD_LED = {
    'en': ['on', 'off'],
    'zh-tw': ['亮', '暗'],
    'zh-cn': ['亮', '暗'],
    'pt': ['ligado', 'desligado'],
    'pt-br': ['ligado', 'desligado'],
    'fr': ['allumée', 'éteinte'],
    'pl': ['włącz', 'wyłącz'],
};

// HAT BLOCK DESCRIPTORS
const HAT_BUTTONS = {
    'en': 'When [BUTTON] is [PRESSED_RELEASED]',
    'zh-tw': '當 [BUTTON] [PRESSED_RELEASED]',
    'zh-cn': '当 [BUTTON] [PRESSED_RELEASED]',
    'pt': 'Quando o botão [BUTTON] estiver [PRESSED_RELEASED]',
    'pt-br': 'Quando o botão [BUTTON] estiver [PRESSED_RELEASED]',
    'fr': 'si [BUTTON] est [PRESSED_RELEASED]',
    'pl': 'Kiedy [BUTTON] jest [PRESSED_RELEASED]',
};

const HAT_SLIDE_SWITCH = {
    'en': 'When slide switch is moved [LEFT_RIGHT]',
    'zh-tw': '當開關朝向 [LEFT_RIGHT]',
    'zh-cn': '当开关朝向 [LEFT_RIGHT]',
    'pt': 'Quando o botão switch mover para [LEFT_RIGHT]',
    'pt-br': 'Quando o botão switch mover para [LEFT_RIGHT]',
    'fr': "Si l'interrupteur à glissière est déplacé à [LEFT_RIGHT]",
    'pl': "kiedy suwak jest przesunięty w [LEFT_RIGHT]",
};

const HAT_LIGHT_TEMPERATURE = {
    'en': 'When [SENSOR] [COMPARISON] [VALUE]',
    'zh-tw': '當 [SENSOR] [COMPARISON] [VALUE]',
    'zh-cn': '当 [SENSOR] [COMPARISON] [VALUE]',
    'pt': 'Quando [SENSOR] [COMPARISON] [VALUE]',
    'pt-br': 'Quando [SENSOR] [COMPARISON] [VALUE]',
    'fr': 'si [SENSOR] [COMPARISON] [VALUE]',
    'pl': 'Kiedy [SENSOR] [COMPARISON] [VALUE]',
};

const HAT_TILTED = {
    'en': 'When CPX position is [TILT_POSITION]',
    'zh-tw': '當燈板 [TILT_POSITION]',
    'zh-cn': '当灯板 [TILT_POSITION]',
    'pt': 'Quando a CPX estiver [TILT_POSITION]',
    'pt-br': 'Quando a CPX estiver na posição [TILT_POSITION]',
    'fr': 'Si la carte CPX est [TILT_POSITION]',
    'pl': 'Kiedy pozycja CPX jest  [TILT_POSITION]',
};

const HAT_LOUD_SOUND = {
    'en': 'When a loud sound is detected',
    'zh-tw': '當偵測到聲音',
    'zh-cn': '当侦测到声音',
    'pt': 'Quando um som alto for detectado',
    'pt-br': 'Quando um som alto for detectado',
    'fr': 'Si un son fort est détecté',
    'pl': 'Kiedy wykryto głośny dźwięk',
};

const HAT_TOUCHPAD = {
    'en': 'When touchpad [TOUCHPAD] is [TOUCH_STATE]',
    'zh-tw': '當連接腳位 [TOUCHPAD] [TOUCH_STATE]',
    'zh-cn': '当连接脚位 [TOUCHPAD] [TOUCH_STATE]',
    'pt': 'Quando o touchpad [TOUCHPAD] for [TOUCH_STATE]',
    'pt-br': 'Quando o touchpad [TOUCHPAD] for [TOUCH_STATE]',
    'fr': 'Si le touchpad [TOUCHPAD] est [TOUCH_STATE]',
    'pl': 'Kiedy panel dotykowy [TOUCHPAD] jest [TOUCH_STATE]',
};

// boolean blocks
const BOOL_AB_SWITCH = {
    'en': '[BUTTON] [PRESSED_RELEASED]',
    'zh-tw': '[BUTTON] [PRESSED_RELEASED]',
    'zh-cn': '[BUTTON] [PRESSED_RELEASED]',
    'pt': '[BUTTON] [PRESSED_RELEASED]',
    'pt-br': '[BUTTON] [PRESSED_RELEASED]',
    'fr': '[BUTTON] [PRESSED_RELEASED]',
    'pl': '[BUTTON] [PRESSED_RELEASED]',
};

const BOOL_SLIDE_SWITCH = {
    'en': 'slide switch on the [LEFT_RIGHT]',
    'zh-tw': '開關朝向 [LEFT_RIGHT]',
    'zh-cn': '开关朝向 [LEFT_RIGHT]',
    'pt': 'slide switch on the [LEFT_RIGHT]',
    'pt-br': 'slide switch on the [LEFT_RIGHT]',
    'fr': 'interrupteur à glissière à [LEFT_RIGHT]',
    'pl': 'suwak na [LEFT_RIGHT]',
};

const BOOL_LIGHT_TEMP = {
    'en': '[SENSOR] is [COMPARISON] [VALUE]',
    'zh-tw': '[SENSOR] [COMPARISON] [VALUE]',
    'zh-cn': '[SENSOR] [COMPARISON] [VALUE]',
    'pt': '[SENSOR] for [COMPARISON] [VALUE]',
    'pt-br': '[SENSOR] for [COMPARISON] [VALUE]',
    'fr': '[SENSOR] est [COMPARISON] [VALUE]',
    'pl': '[SENSOR] jest [COMPARISON] [VALUE]',
};

const BOOL_TILTED = {
    'en': 'CPX position is [TILT_POSITION]',
    'zh-tw': '燈板 [TILT_POSITION]',
    'zh-cn': '灯板 [TILT_POSITION]',
    'pt': 'posição da CPX for [TILT_POSITION]',
    'pt-br': 'posição da CPX for [TILT_POSITION]',
    'fr': 'La carte CPX est [TILT_POSITION]',
    'pl': 'pozycja CPX jest [TILT_POSITION]',
};

const BOOL_TOUCH_PAD = {
    'en': 'touchpad [TOUCHPAD] is [TOUCH_STATE]',
    'zh-tw': '連接腳位 [TOUCHPAD] [TOUCH_STATE]',
    'zh-cn': '连接脚位 [TOUCHPAD] [TOUCH_STATE]',
    'pt': 'touchpad [TOUCHPAD] for [TOUCH_STATE]',
    'pt-br': 'touchpad [TOUCHPAD] for [TOUCH_STATE]',
    'fr': 'le touchpad [TOUCHPAD] est [TOUCH_STATE]',
    'pl': 'panel dotykowy [TOUCHPAD] jest [TOUCH_STATE]',
};

const REPORTER_AB_SWITCH = {
    'en': 'Button [BUTTON]',
    'zh-tw': '按鈕 [BUTTON]',
    'zh-cn': '按钮 [BUTTON]',
    'pt': 'Botão [BUTTON]',
    'pt-br': 'Botão [BUTTON]',
    'fr': 'Bouton [BUTTON]',
    'pl': 'Przycisk [BUTTON]',
};

const REPORTER_SLIDE_SWITCH = {
    'en': 'Slide switch',
    'zh-tw': '開關',
    'zh-cn': '开关',
    'pt': 'botão switch',
    'pt-br': 'botão switch',
    'fr': 'Interrupteur à glissière',
    'pl': 'Suwak',

};

const REPORTER_LIGHT_TEMP = {
    'en': '[SENSOR]',
    'zh-tw': '[SENSOR]',
    'zh-cn': '[SENSOR]',
    'pt': '[SENSOR]',
    'pt-br': '[SENSOR]',
    'fr': '[SENSOR]',
    'pl': '[SENSOR]',
};

const REPORTER_TILT = {
    'en': 'CPX position is [TILT_POSITION]',
    'zh-tw': '燈板 [TILT_POSITION]',
    'zh-cn': '灯板 [TILT_POSITION]',
    'pt': 'posição da CPX [TILT_POSITION]',
    'pt-br': 'posição da CPX [TILT_POSITION]',
    'fr': 'La carte CPX est [TILT_POSITION]',
    'pl': 'pozycja CPX jest [TILT_POSITION]',
};

const REPORTER_TOUCHPAD = {
    'en': 'touchpad [TOUCHPAD]',
    'zh-tw': '連接腳位 [TOUCHPAD]',
    'zh-cn': '连接脚位 [TOUCHPAD]',
    'pt': 'touchpad [TOUCHPAD]',
    'pt-br': 'touchpad [TOUCHPAD]',
    'fr': 'le touchpad [TOUCHPAD]',
    'pl': 'płytka dotykowa [TOUCHPAD]',
};

// command blocks
const COMMAND_SET_PIXEL = {
    'en': 'Pixel [NEOPIXEL] R [RED] G [GREEN] B [BLUE]',
    'zh-tw': '全彩LED [NEOPIXEL] 紅 [RED] 綠 [GREEN] 藍 [BLUE]',
    'zh-cn': '全彩LED [NEOPIXEL] 红 [RED] 绿 [GREEN] 蓝 [BLUE]',
    'pt': 'Pixel [NEOPIXEL] R [RED] G [GREEN] B [BLUE]',
    'pt-br': 'Pixel [NEOPIXEL] R [RED] G [GREEN] B [BLUE]',
    'fr': 'Pixel [NEOPIXEL] R [RED] V [GREEN] B [BLUE]',
    'pl': 'Pixel [NEOPIXEL] R [RED] G [GREEN] B [BLUE]',
};

const COMMAND_TONE = {
    'en': 'Tone [FREQ] Hz [DURATION] ms',
    'zh-tw': '播放音調 [FREQ] 赫茲 [DURATION] 毫秒',
    'zh-cn': '播放音调 [FREQ] 赫兹 [DURATION] 毫秒',
    'pt': ' Criar com com [FREQ] Hz  e [DURATION] ms',
    'pt-br': ' Criar com com [FREQ] Hz  e [DURATION] ms',
    'fr': 'Son [FREQ] Hz [DURATION] ms',
    'pl': 'Dźwięk [FREQ] Hz [DURATION] ms',
};

const COMMAND_BOARD_LED = {
    'en': 'Board LED [LED_STATE]',
    'zh-tw': 'D13 LED [LED_STATE]',
    'zh-cn': 'D13 LED [LED_STATE]',
    'pt': 'Definir Led da placa como [LED_STATE]',
    'pt-br': 'Definir Led da placa como [LED_STATE]',
    'fr': 'LED D13 [LED_STATE]',
    'pl': 'Dioda LED płytki [LED_STATE]',
};

const FormWSClosed = {
    'en': "WebSocket Connection Is Closed.",
    'zh-tw': "硬體連線中斷",
    'zh-cn': "硬件联机中断",
    'pt': "A Conexão do WebSocket está fechada.",
    'pt-br': "A Conexão do WebSocket está fechada.",
    'fr': "La connexion au WebSocket est fermée.",
    'pl': "Połączenie WebSocket jest zamknięte.",
};

let data_store = {
    'a': 0, 'b': 0, 'light': 0, 'temp': 0.0,
    'slide': 1, 'sound': 0, 'tilted': [0, 0],
    'touch1': 0, 'touch2': 0, 'touch3': 0, 'touch4': 0,
    'touch5': 0, 'touch6': 0, 'touch7': 0
};

class Scratch3CpxOneGPIO {
    constructor(runtime) {
        the_locale = this._setLocale();
        this.runtime = runtime;
    }

    getInfo() {
        the_locale = this._setLocale();
        // connect to the websocket server
        this.connect();

        return {
            id: 'onegpioCpx',
            color1: '#0C5986',
            color2: '#34B0F7',
            name: 'OneGpio Playground Express',
            blockIconURI: 'data:image/png;base64,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',
            blocks: [
                {
                    opcode: 'hat_button_pressed',
                    blockType: BlockType.HAT,
                    text: HAT_BUTTONS[the_locale],
                    arguments: {
                        BUTTON: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_PUSH_BUTTONS[the_locale][0],
                            menu: 'pushButtons'
                        },
                        PRESSED_RELEASED: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_PUSH_BUTTON_STATE[the_locale][0],
                            menu: 'pushButtonStates'
                        },
                    }
                },
                {
                    opcode: 'hat_slide_moved',
                    blockType: BlockType.HAT,
                    text: HAT_SLIDE_SWITCH[the_locale],
                    arguments: {
                        LEFT_RIGHT: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_SLIDE_SWITCH_POSITION[the_locale][0],
                            menu: 'slidePositions'
                        },
                    }
                },
                {
                    opcode: 'hat_tilted',
                    blockType: BlockType.HAT,
                    text: HAT_TILTED[the_locale],
                    arguments: {
                        TILT_POSITION: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_TILT_POSITION[the_locale][0],
                            menu: 'tiltPositions'
                        }
                    }
                },
                {
                    opcode: 'hat_loud_sound',
                    blockType: BlockType.HAT,
                    text: HAT_LOUD_SOUND[the_locale],
                },
                {
                    opcode: 'hat_touchpad',
                    blockType: BlockType.HAT,
                    text: HAT_TOUCHPAD[the_locale],
                    arguments: {
                        TOUCHPAD: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '1',
                            menu: 'touchpads'
                        },
                        TOUCH_STATE: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_TOUCH_PAD_STATES[the_locale][0],
                            menu: 'touchPadStates'
                        },
                    }
                },
                '---',
                {
                    opcode: 'bool_button_pressed',
                    blockType: BlockType.BOOLEAN,
                    text: BOOL_AB_SWITCH[the_locale],
                    arguments: {
                        BUTTON: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_PUSH_BUTTONS[the_locale][0],
                            menu: 'pushButtons'
                        },
                        PRESSED_RELEASED: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_PUSH_BUTTON_STATE[the_locale][0],
                            menu: 'pushButtonStates'
                        },
                    }
                },
                {
                    opcode: 'bool_light_temp_comparison',
                    blockType: BlockType.BOOLEAN,
                    text: BOOL_LIGHT_TEMP[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_LIGHT_TEMPERATURE[the_locale][0],
                            menu: 'lightTemperature'
                        },
                        COMPARISON: {
                            type: ArgumentType.STRING,
                            defaultValue: '>',
                            menu: 'compare'
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 0,
                        }
                    }
                },
                {
                    opcode: 'bool_tilted',
                    blockType: BlockType.BOOLEAN,
                    text: BOOL_TILTED[the_locale],
                    arguments: {
                        TILT_POSITION: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_TILT_POSITION[the_locale][0],
                            menu: 'tiltPositions'
                        }
                    }
                },
                {
                    opcode: 'bool_touch_pad',
                    blockType: BlockType.BOOLEAN,
                    text: BOOL_TOUCH_PAD[the_locale],
                    arguments: {
                        TOUCHPAD: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '1',
                            menu: 'touchpads'
                        },
                        TOUCH_STATE: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_TOUCH_PAD_STATES[the_locale][0],
                            menu: 'touchPadStates'
                        },
                    }
                },
                '---',

                {
                    opcode: 'reporter_light_temp',
                    blockType: BlockType.REPORTER,
                    text: REPORTER_LIGHT_TEMP[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_LIGHT_TEMPERATURE[the_locale][0],
                            menu: 'lightTemperature'
                        }
                    }
                },

                '---',
                {
                    opcode: 'command_pixel_write',
                    blockType: BlockType.COMMAND,
                    text: COMMAND_SET_PIXEL[the_locale],

                    arguments: {
                        NEOPIXEL: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '1',
                            menu: "neopixels"
                        },
                        RED: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '128',
                        },
                        GREEN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '128',
                        },
                        BLUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '128',
                        },
                    }
                },
                {
                    opcode: 'command_tone',
                    blockType: BlockType.COMMAND,
                    text: COMMAND_TONE[the_locale],

                    arguments: {
                        FREQ: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '1000',
                        },
                        DURATION: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '500',
                        },
                        GREEN: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '128',
                        },
                        BLUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: '128',
                        },
                    }
                },
                {
                    opcode: 'command_board_led',
                    blockType: BlockType.COMMAND,
                    text: COMMAND_BOARD_LED[the_locale],

                    arguments: {
                        LED_STATE: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_BOARD_LED[the_locale][0],
                            menu: 'boardLedStates'
                        }
                    }
                },


            ],
            menus: {

                pushButtons: 'getAllPushButtons',
                lightTemperature: 'getAllLightTemperature',
                pushButtonStates: 'getAllPushButtonStates',
                slidePositions: 'getAllSlidePositions',
                touchPadStates: 'getAllTouchPadStates',
                tiltPositions: 'getAllTiltPostions',
                boardLedStates: 'getAllBoardLedStates',
                neopixels:
                    {
                        items: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],

                    },
                touchpads: {
                    items: ['1', '2', '3', '4', '5', '6', '7',]
                },
                compare: {
                    items: ['>', '<']
                },
            }
        };
    }

    getAllPushButtons() {
        return MENU_PUSH_BUTTONS[the_locale];
    }

    getAllLightTemperature() {
        return MENU_LIGHT_TEMPERATURE[the_locale];
    }

    getAllPushButtonStates() {
        return MENU_PUSH_BUTTON_STATE[the_locale];
    }

    getAllSlidePositions() {
        return MENU_SLIDE_SWITCH_POSITION[the_locale];
    }

    getAllTouchPadStates() {
        return MENU_TOUCH_PAD_STATES[the_locale];
    }

    getAllTiltPostions() {
        return MENU_TILT_POSITION[the_locale];
    }

    getAllBoardLedStates() {
        return MENU_BOARD_LED[the_locale];
    }

    // The block handlers

    // command blocks

    hat_button_pressed(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.hat_button_pressed.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            if (args['BUTTON'] === this.getAllPushButtons()[0]) {
                if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[0]) {
                    return data_store['a'] === 1;
                } else {
                    if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[1]) {
                        return data_store['a'] === 0;
                    }
                }
            }
            // for button b
            if (args['BUTTON'] === this.getAllPushButtons()[1]) {
                if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[0]) {
                    return data_store['b'] === 1;
                } else {
                    if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[1]) {
                        return data_store['b'] === 0;
                    }
                }
            }
        }
    }

    hat_slide_moved(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.hat_slide_moved.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let item_index = this.getAllSlidePositions().indexOf(args['LEFT_RIGHT']);
            item_index = parseInt(item_index, 10);

            // testing for pressed
            if (item_index === 0) {
                return data_store['slide'] === 1;
            } else {
                return data_store['slide'] === 0;
            }
        }
    }

    hat_tilted(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }
        if (!connected) {
            let callbackEntry = [this.hat_tilted.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let current_position = data_store['tilted'];
            let sensor_text = args['TILT_POSITION'];
            // get its index in the list of menu items
            let item_index = this.getAllTiltPostions().indexOf(sensor_text);
            item_index = parseInt(item_index, 10);
            // get index for the block position
            // ['flat', 'up', 'down', 'left', 'right',],
            if (item_index === 0 && data_store['tilted'][0] === 0) { // flat
                return true;
            } else if (item_index === 1 && data_store['tilted'][0] === 1) { // up
                return true;
            } else if (item_index === 2 && data_store['tilted'][0] === 2) { // down
                return true;
            } else if (item_index === 3 && data_store['tilted'][1] === 3) { // down
                return true;
            } else if (item_index === 4 && data_store['tilted'][1] === 4) { // down
                return true;
            } else {
                return false;
            }
        }
    }

    hat_loud_sound
    (args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.hat_loud_sound.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            return data_store['sound'] > 540;
        }
    }

    hat_touchpad(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.hat_touchpad.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let touchpad = parseInt(args['TOUCHPAD'], 10);
            let state = args['TOUCH_STATE'];
            let index = this.getAllTouchPadStates().indexOf(state);
            let current_state = 0;
            switch (touchpad) {
                case 1:
                    current_state = data_store['touch1'];
                    break;
                case 2:
                    current_state = data_store['touch2'];
                    break;
                case 3:
                    current_state = data_store['touch3'];
                    break;
                case 4:
                    current_state = data_store['touch4'];
                    break;
                case 5:
                    current_state = data_store['touch5'];
                    break;
                case 6:
                    current_state = data_store['touch6'];
                    break;
                case 7:
                    current_state = data_store['touch7'];
                    break;
                default:
                    break;
            }
            if (index === 0 && current_state) { //touched and touched selected
                return true;
            } else if (index === 1 && !current_state) { //released and released selected
                return true;
            } else {
                return false;
            }
        }
    }


    bool_button_pressed(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }
        if (!connected) {
            let callbackEntry = [this.bool_button_pressed.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // for button a
            if (args['BUTTON'] === this.getAllPushButtons()[0]) {
                if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[0]) {
                    return data_store['a'] === 1;
                } else {
                    if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[1]) {
                        return data_store['a'] === 0;
                    }
                }
            }
            // for button b
            if (args['BUTTON'] === this.getAllPushButtons()[1]) {
                if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[0]) {
                    return data_store['b'] === 1;
                } else {
                    if (args['PRESSED_RELEASED'] === this.getAllPushButtonStates()[1]) {
                        return data_store['b'] === 0;
                    }
                }
            }
        }
    }

    bool_light_temp_comparison(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.bool_light_temp_comparison.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let current_value = 0;
            let comp_type = args['COMPARISON'];
            let comp_value = args['VALUE'];
            if (args['SENSOR'] === this.getAllLightTemperature()[0]) {
                current_value = data_store['light'];
            } else {
                current_value = data_store['temp']
            }
            if (comp_type === '>') {
                return current_value > comp_value;
            } else {
                return current_value < comp_value;
            }
        }
    }

    bool_tilted(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.bool_tilted.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get the current position
            let current_position = data_store['tilted'];
            let sensor_text = args['TILT_POSITION'];
            // get its index in the list of menu items
            let item_index = this.getAllTiltPostions().indexOf(sensor_text);
            item_index = parseInt(item_index, 10);
            // get index for the block position
            // ['flat', 'up', 'down', 'left', 'right',],
            if (item_index === 0) { // flat
                return data_store['tilted'][0] === 0 &&
                    data_store['tilted'][1] === 0;
            } else if (item_index === 1) { //up
                return data_store['tilted'][0] === 1;
            } else if (item_index === 2) { //down
                return data_store['tilted'][0] === 2;

            } else if (item_index === 3) { //left
                return data_store['tilted'][1] === 3;
            } else if (item_index === 4) { //left
                return data_store['tilted'][1] === 4;

            }
        }
    }

    bool_touch_pad(args) {

        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.bool_touchpad.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let touchpad = parseInt(args['TOUCHPAD'], 10);
            let value = false;

            switch (touchpad) {
                case 1:
                    value = data_store['touch1'];
                    break;
                case 2:
                    value = data_store['touch2'];
                    break;
                case 3:
                    value = data_store['touch3'];
                    break;
                case 4:
                    value = data_store['touch4'];
                    break;
                case 5:
                    value = data_store['touch5'];
                    break;
                case 6:
                    value = data_store['touch6'];
                    break;
                case 7:
                    value = data_store['touch7'];
                    break;
                default:
                    console.log('bool_touch_pad unexpected pad value', touchpad);
                    break;
            }
            if (args['TOUCH_STATE'] === this.getAllTouchPadStates()[0]) {
                return Boolean(value);
            } else {
                return Boolean(value ^ 1);
            }
        }
    }


    reporter_light_temp(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.reporter_light_temp.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // test for light
            if (args['SENSOR'] === this.getAllLightTemperature()[0]) {
                return data_store['light'];
            } else {
                return data_store['temp']
            }
        }
    }

    command_pixel_write(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }

        }

        if (!connected) {
            let callbackEntry = [this.command_pixel_write.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let pixel = args['NEOPIXEL'];
            pixel = parseInt(pixel, 10);
            pixel -= 1;

            let red = args['RED'];
            red = parseInt(red, 10);

            let green = args['GREEN'];
            green = parseInt(green, 10);

            let blue = args['BLUE'];
            blue = parseInt(blue, 10);

            msg = {"command": 'pixel', 'pixel': pixel, 'red': red, 'green': green, 'blue': blue};
            msg = JSON.stringify(msg);
            window.socketx.send(msg);
        }
    }

    command_tone(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.tone_on.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let freq = args['FREQ'];
            freq = parseInt(freq, 10);
            let duration = args['DURATION'];
            duration = parseInt(duration, 10);
            // make sure duration maximum is 5 seconds
            if (duration > 5000) {
                duration = 5000;
            }

            msg = {"command": 'play_tone', 'pin': 99, 'freq': freq, 'duration': duration};
            msg = JSON.stringify(msg);
            window.socketx.send(msg);

        }
    }

    command_board_led(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.command_board_led.bind(this), args];
            wait_open.push(callbackEntry);
        } else {

            let state = args['LED_STATE'];
            let item_index = this.getAllBoardLedStates().indexOf(state);
            item_index = parseInt(item_index, 10);

            if (item_index === 0) {
                value = 1;
            } else {
                value = 0;
            }
            msg = {"command": 'digital_write', 'pin': 13, 'value': value};
            msg = JSON.stringify(msg);
            window.socketx.send(msg);

        }
    }

    // end of block handlers

    _setLocale() {
        let now_locale = '';
        switch (formatMessage.setup().locale) {
            case 'en':
                now_locale = 'en';
                break;
            case 'zh-tw':
                now_locale= 'zh-tw';
                break;
            case 'zh-cn':
                now_locale= 'zh-cn';
                break;
            case 'pt-br':
            case 'pt':
                now_locale='pt-br';
                break;
            case 'fr':
                now_locale='fr';
                break;
            case 'pl':
                now_locale='pl';
                break;
            default:
                now_locale = 'en';
                break;
        }
        return now_locale;
    }

    // helpers
    connect() {
        if (connected) {
            // ignore additional connection attempts
            return;
        } else {
            connect_attempt = true;
            window.socketx = new WebSocket("ws://127.0.0.1:9003");
            msg = JSON.stringify({"id": "to_cpx_gateway"});
        }


        // websocket event handlers
        window.socketx.onopen = function () {
            // connection complete
            connected = true;
            connect_attempt = true;
            // the message is built above
            try {
                //ws.send(msg);
                window.socketx.send(msg);

            } catch (err) {
                // ignore this exception
            }
            for (let index = 0; index < wait_open.length; index++) {
                let data = wait_open[index];
                data[0](data[1]);
            }
        };

        window.socketx.onclose = function () {

            if (alerted === false) {
                alerted = true;
                alert(FormWSClosed[the_locale]);
            }
            connected = false;
        };

        // reporter messages from the board
        window.socketx.onmessage = function (message) {
            msg = JSON.parse(message.data);
            let report_type = msg['report'];

            // set the incoming value in the data store
            data_store[report_type] = msg['value'];
        };
    }
}

module.exports = Scratch3CpxOneGPIO;
