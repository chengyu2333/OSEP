/*
This is the Scratch 3 extension to remotely control an
Arduino Uno, ESP-8666, or Raspberry Pi


 Copyright (c) 2019 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

// Boiler plate from the Scratch Team
const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const formatMessage = require('format-message');

require('sweetalert');

let lastDataSample = [0, 0, 0, 0, 0, 0, 0, 0];

let connection_pending = false;

// general outgoing websocket message holder
let msg = null;

// flag to indicate if the user connected to a board
let connected = false;

// flag to indicate if a websocket connect was
// ever attempted.
let connect_attempt = false;

// an array to buffer operations until socket is opened
let wait_open = [];

let the_locale = null;

/* map of sensors to indices for ALL_SENSORS
["Slider", "Light", "Sound", "Button", "A", "B", "C", "D"]
The key is the same used by the gateway when
values are published to the extension.
data value 0 = D  analog inverted logic
data value 1 = C  analog inverted logic
data value 2 = B  analog inverted logic
data value 3 = Button  digital inverted logic
data value 4 = A  analog inverted logic
data value 5 = Light  analog inverted logic
data value 6 = sound  analog
data value 7 = slider analog
*/
let theAllSensorMap =

    {0: 7, 1: 5, 2: 6, 3: 3, 4: 4, 5: 2, 6: 1, 7: 0};

/* map of sensors to indices for NON_BUTTON_SENSORS
["Slider", "Light", "Sound", "A", "B", "C", "D"]
values are published to the extension.
data value 0 = D  analog inverted logic
data value 1 = C  analog inverted logic
data value 2 = B  analog inverted logic
data value 3 = Button  digital inverted logic
data value 4 = A  analog inverted logic
data value 5 = Light  analog inverted logic
data value 6 = sound  analog
data value 7 = slider analog
*/

let theNonButtonSensorMap =
    //
    {0: 7, 1: 5, 2: 6, 3: 4, 4: 2, 5: 1, 6: 0};

// flag to indicate alert already generated
let alerted = false;

// General Alert
const FormWSClosed = {
    'en': "WebSocket Connection Is Closed.",
    'zh-tw': "硬體連線中斷",
    'zh-cn': "硬件联机中断",
    'pt-br': "A Conexão do WebSocket está Fechada",
    'pt': "A Conexão do WebSocket está Fechada",
    'fr': "Connexion WebSocket Fermée.",
};

const MENU_NON_BUTTON_SENSORS = {
    'en': ["Slider", "Light", "Sound", "A", "B", "C", "D"],
    'zh-tw': ["滑桿", "光線", "聲音", "A", "B", "C", "D"],
    'zh-cn': ["滑杆", "光线", "声音", "A", "B", "C", "D"],
    'pt-br': ["Controle deslizante", "Luz", "Som", "A", "B", "C", "D"],
    'pt': ["Controle deslizante", "Luz", "Som", "A", "B", "C", "D"],
    'fr': ["Glissière", "Lumière", "Son", "A", "B", "C", "D"],
};

const MENU_ALL_SENSORS = {
    'en': ["Slider", "Light", "Sound", "Button", "A", "B", "C", "D"],
    'zh-tw': ["滑桿", "光線", "聲音", "按鈕", "A", "B", "C", "D"],
    'zh-cn': ["滑杆", "光线", "声音", "按钮", "A", "B", "C", "D"],
    'pt-br': ["Controle deslizante", "Luz", "Som", "Botão", "A", "B", "C", "D"],
    'pt': ["Controle deslizante", "Luz", "Som", "Botão", "A", "B", "C", "D"],
    'fr': ["Glissière", "Lumière", "Son", "Bouton", "A", "B", "C", "D"],
};

const MENU_COMPARISONS = {
    'en': ['>', '<'],
    'zh-tw': ['>', '<'],
    'zh-cn': ['>', '<'],
    'pt-br': ['>', '<'],
    'pt': ['>', '<'],
    'fr': ['>', '<'],
};

const MENU_BUTTON_STATES = {
    'en': ["pressed", "released"],
    'zh-tw': ["被按下", "被放開"],
    'zh-cn': ["被按下", "被放开"],
    'pt-br': ["pressionado", "liberado"],
    'pt': ["pressionado", "liberado"],
    'fr': ["appuyé", "relaché"],
};

const FormBetween = {
    'en': 'When [SENSOR] value is between [LOW] and [HIGH]',
    'zh-tw': '當 [SENSOR] 的偵測值介於 [LOW] 與 [HIGH] 之間',
    'zh-cn': '当 [SENSOR] 的侦测值介于 [LOW] 与 [HIGH] 之间',
    'pt-br': 'Quando [SENSOR] estiver entre [LOW] e [HIGH]',
    'pt': 'Quando [SENSOR] estiver entre [LOW] e [HIGH]',
    'fr': 'Si la valeur de [SENSOR] est entre [LOW] et [HIGH]',
};

const FormComparison = {
    'en': 'When [SENSOR] [COMP] [VALUE].',
    'zh-tw': '當 [SENSOR] 的偵測值 [COMP] [VALUE]',
    'zh-cn': '当 [SENSOR] 的侦测值 [COMP] [VALUE]',
    'pt-br': 'Quando [SENSOR] for [COMP] que [VALUE]',
    'pt': 'Quando [SENSOR] for [COMP] que [VALUE]',
    'fr': 'si [SENSOR] [COMP] [VALUE].',
};

const FormButton = {
    'en': 'When Button [STATE].',
    'zh-tw': '當按鈕 [STATE]',
    'zh-cn': '当按钮 [STATE]',
    'pt-br': 'Quando o botão estiver [STATE].',
    'pt': 'Quando o botão estiver [STATE].',
    'fr': 'Si Bouton [STATE].',
};

const FormIsButtonPressed = {
    'en': 'Is Button Pressed?',
    'zh-tw': '按鈕被按下？',
    'zh-cn': '按钮被按下？',
    'pt-br': 'O botão está pressionado?',
    'pt': 'O botão está pressionado?',
    'fr': 'Bouton appuyé ?',

};


const FormIsSensorComparison = {
    'en': 'Is [SENSOR] [COMP] [VALUE] ?',
    'zh-tw': '[SENSOR] 的偵測值 [COMP] [VALUE] ？',
    'zh-cn': '[SENSOR] 的侦测值 [COMP] [VALUE] ？',
    'pt-br': '[SENSOR] está [COMP] [VALUE] ?',
    'pt': '[SENSOR] está [COMP] [VALUE] ?',
    'fr': 'Est-ce que [SENSOR] [COMP] [VALUE] ?',
};

const FormCurrentSensorValue = {
    'en': '[SENSOR] current value.',
    'zh-tw': '[SENSOR] 的偵測值',
    'zh-cn': '[SENSOR] 的侦测值',
    'pt': 'Ler valor atual: [SENSOR]',
    'pt-br': 'Ler valor atual: [SENSOR]',
    'fr': 'valeur actuelle de [SENSOR].',
};

const FormRangeConverter = {
    'en': 'Convert [SENSOR] value to a range of [RANGE1] to [RANGE2]',
    'zh-tw': '轉換 [SENSOR] 的偵測值到 [RANGE1] 與 [RANGE2] 之間',
    'zh-cn': '转换 [SENSOR] 的侦测值到 [RANGE1] 与 [RANGE2] 之间',
    'pt-br': 'Converte valor: [SENSOR] para que fique entre [RANGE1] e [RANGE2]',
    'pt': 'Converte valor: [SENSOR] para que fique entre [RANGE1] e [RANGE2]',
    'fr': 'Convertir la valeur de [SENSOR] dans la plage [RANGE1] à [RANGE2]',
};


class Scratch3PicoboardOneGPIO {
    constructor(runtime) {
        the_locale = this._setLocale();
        this.runtime = runtime;
    }

    getInfo() {
        the_locale = this._setLocale();
        // connect to the websocket server
        this.connect();

        return {
            id: 'onegpioPicoboard',
            color1: '#0C5986',
            color2: '#34B0F7',
            name: 'OneGpio Picoboard',
            blockIconURI: 'data:image/png;base64,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',
            blocks: [
                {
                    opcode: 'sensor_comparison',
                    blockType: BlockType.HAT,
                    text: FormComparison[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        COMP: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_COMPARISONS[the_locale][0],
                            menu: 'comparisons'
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50,
                        }
                    }
                },
                {
                    opcode: 'button_change',
                    blockType: BlockType.HAT,
                    text: FormButton[the_locale],
                    arguments: {
                        STATE: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_BUTTON_STATES[the_locale][0],
                            menu: 'button_states'
                        }
                    }
                },
                {
                    opcode: 'sensor_between',
                    blockType: BlockType.HAT,
                    text: FormBetween[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        LOW: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 25,
                        },
                        HIGH: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 75,
                        }
                    }
                },
                {
                    opcode: 'is_button_pressed',
                    blockType: BlockType.BOOLEAN,
                    text: FormIsButtonPressed[the_locale],
                },
                {
                    opcode: 'is_sensor',
                    blockType: BlockType.BOOLEAN,
                    text: FormIsSensorComparison[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        COMP: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_COMPARISONS[the_locale][0],
                            menu: 'comparisons'
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50,
                        }
                    }
                },
                {
                    opcode: 'current_sensor_value',
                    blockType: BlockType.REPORTER,
                    text: FormCurrentSensorValue[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_ALL_SENSORS[the_locale][0],
                            menu: 'all_sensors'
                        }
                    }
                },
                {
                    opcode: 'range_convert',
                    blockType: BlockType.REPORTER,
                    text: FormRangeConverter[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        RANGE1: {
                            type: ArgumentType.NUMBER,
                            defaultValue: -240,
                        },
                        RANGE2: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 240,
                        }
                    }
                },
            ],
            menus: {
                all_sensors: 'getAllSensorMenuItems',
                //non_button_sensors: MENU_NON_BUTTON_SENSORS[the_locale],
                non_button_sensors: 'getAllNonButtonMenuItems',
                //button_states: MENU_BUTTON_STATES[the_locale],
                button_states: 'get_button_states',

                //all_sensors: MENU_ALL_SENSORS[the_locale],

                comparisons: MENU_COMPARISONS[the_locale],
            }
        };
    }

    getAllSensorMenuItems() {
        return MENU_ALL_SENSORS[the_locale];
    }

    getAllNonButtonMenuItems() {
        return MENU_NON_BUTTON_SENSORS[the_locale];
    }

    get_button_states() {
        return MENU_BUTTON_STATES[the_locale];
    }

    mapAllSensors(device) {
        //["Slider", "Light", "Sound", "Button", "A", "B", "C", "D"]
        /*
        data value 0 = D  analog inverted logic
        data value 1 = C  analog inverted logic
        data value 2 = B  analog inverted logic
        data value 3 = Button  digital inverted logic
        data value 4 = A  analog inverted logic
        data value 5 = Light  analog inverted logic
        data value 6 = sound  analog
        data value 7 = slider analog
         */
        //let theAllSensorMap = {0: 7, 1: 5, 2: 6, 3: 3, 4: 4, 5: 2, 6: 1, 7:0 }
        return theAllSensorMap[device];
    }

    mapNonButtonSensors(device) {
        //["Slider", "Light", "Sound", "A", "B", "C", "D"]
        return theNonButtonSensorMap[device];

    }

    // The block handlers

    sensor_between(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.sensor_between.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];
            let low = parseInt(args['LOW'], 10);
            let high = parseInt(args['HIGH'], 10);
            return value >= low && value <= high;
        }
    }

    sensor_comparison(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.sensor_comparison.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];
            let comp_type = args['COMP'];
            let comp_value = parseInt(args['VALUE'], 10);
            if (comp_type === '<') {
                return value < comp_value;
            } else {
                return value > comp_value;
            }
        }

    }

    button_change(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.button_change.bind(this), args];
            wait_open.push(callbackEntry);
        } else {

            let item_index = this.get_button_states().indexOf(args['STATE']);
            // testing for pressed
            if (item_index === 0) {
                return lastDataSample[3] === 1;
            } else {
                return lastDataSample[3] === 0;
            }
        }
    }

    is_button_pressed(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.is_button_pressed.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get current button value
            return Boolean(Number(lastDataSample[3]));

        }

    }

    is_sensor(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.is_sensor.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];
            let comp_type = args['COMP'];
            let comp_value = parseInt(args['VALUE'], 10);
            if (comp_type === '<') {
                return value < comp_value;
            } else {
                return value > comp_value;
            }
        }

    }

    current_sensor_value(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.current_sensor_value.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get the text of the menu item
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllSensorMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapAllSensors(item_index);
            // retrieve the data from the last data sample
            return lastDataSample[map_key];
        }

    }

    range_convert(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.range_convert.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get the text of the menu item
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];

            let high = parseInt(args['RANGE2'], 10);
            let low = parseInt(args['RANGE1'], 10);
            return Math.round(((value) * ((high - low) / 100)) +
                low);
        }

    }

    // end of block handlers

    _setLocale() {
        let now_locale = '';
        switch (formatMessage.setup().locale) {
            case 'zh-tw':
                now_locale = 'zh-tw';
                break;
            case 'zh-cn':
                now_locale = 'zh-cn';
                break;
            case 'en':
                now_locale = 'en';
                break;
            case 'pt-br':
                now_locale = 'pt-br';
                break;
            case 'pt':
                now_locale = 'pt';
                break;
            case 'fr':
                now_locale = 'fr';
                break;
            default:
                now_locale = 'en';
                break;
        }
        return now_locale;
    }

    // helpers
    connect() {
        if (connected) {
            // ignore additional connection attempts
            return;
        } else {
            connect_attempt = true;
            window.socket = new WebSocket("ws://127.0.0.1:9004");
            msg = JSON.stringify({"id": "to_picoboard_gateway"});
        }


        // websocket event handlers
        window.socket.onopen = function () {
            // connection complete
            connected = true;
            connect_attempt = true;
            // the message is built above
            try {
                //ws.send(msg);
                window.socket.send(msg);

            } catch (err) {
                // ignore this exception
            }
            for (let index = 0; index < wait_open.length; index++) {
                let data = wait_open[index];
                data[0](data[1]);
            }
        };

        window.socket.onclose = function () {
            if (alerted === false) {
                alerted = true;
                alert(FormWSClosed[the_locale]);}
            connected = false;
        };

        // reporter messages from the board
        window.socket.onmessage = function (message) {
            // store the latest incoming data
            msg = JSON.parse(message.data);
            // let report_type = msg["report"];
            lastDataSample = msg['report'];
        };
    }
}

module
    .exports = Scratch3PicoboardOneGPIO;
