/*
This is the Scratch 3 extension to remotely control an
Arduino Uno, ESP-8666, or Raspberry Pi


 Copyright (c) 2019 Alan Yorinks All rights reserved.

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
 Version 3 as published by the Free Software Foundation; either
 or (at your option) any later version.
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
 along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

// Boiler plate from the Scratch Team
const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const formatMessage = require('format-message');

require('sweetalert');

let lastDataSample = [0, 0, 0, 0, 0, 0, 0, 0];

let connection_pending = false;

// general outgoing websocket message holder
let msg = null;

// flag to indicate if the user connected to a board
let connected = false;

// flag to indicate if a websocket connect was
// ever attempted.
let connect_attempt = false;

// an array to buffer operations until socket is opened
let wait_open = [];

let the_locale = null;

/* map of sensors to indices for ALL_SENSORS
["Slider", "Light", "Sound", "Button", "A", "B", "C", "D"]
The key is the same used by the gateway when
values are published to the extension.
data value 0 = D  analog inverted logic
data value 1 = C  analog inverted logic
data value 2 = B  analog inverted logic
data value 3 = Button  digital inverted logic
data value 4 = A  analog inverted logic
data value 5 = Light  analog inverted logic
data value 6 = sound  analog
data value 7 = slider analog
*/
let theAllSensorMap =

    {0: 7, 1: 5, 2: 6, 3: 3, 4: 4, 5: 2, 6: 1, 7: 0};

/* map of sensors to indices for NON_BUTTON_SENSORS
["Slider", "Light", "Sound", "A", "B", "C", "D"]
values are published to the extension.
data value 0 = D  analog inverted logic
data value 1 = C  analog inverted logic
data value 2 = B  analog inverted logic
data value 3 = Button  digital inverted logic
data value 4 = A  analog inverted logic
data value 5 = Light  analog inverted logic
data value 6 = sound  analog
data value 7 = slider analog
*/

let theNonButtonSensorMap =
    //
    {0: 7, 1: 5, 2: 6, 3: 4, 4: 2, 5: 1, 6: 0};

// flag to indicate alert already generated
let alerted = false;

// General Alert
const FormWSClosed = {
    'en': "WebSocket Connection Is Closed.",
    'zh-tw': "硬體連線中斷",
    'zh-cn': "硬件联机中断",
    'pt-br': "A Conexão do WebSocket está Fechada",
    'pt': "A Conexão do WebSocket está Fechada",
    'fr': "Connexion WebSocket Fermée.",
    'pl': "Połączenie WebSocket jest zamknięte.",
};

const MENU_NON_BUTTON_SENSORS = {
    'en': ["Slider", "Light", "Sound", "A", "B", "C", "D"],
    'zh-tw': ["滑桿", "光線", "聲音", "A", "B", "C", "D"],
    'zh-cn': ["滑杆", "光线", "声音", "A", "B", "C", "D"],
    'pt-br': ["Controle deslizante", "Luz", "Som", "A", "B", "C", "D"],
    'pt': ["Controle deslizante", "Luz", "Som", "A", "B", "C", "D"],
    'fr': ["Glissière", "Lumière", "Son", "A", "B", "C", "D"],
    'pl': ["Suwak", "Światło", "Dźwięk", "A", "B", "C", "D"],
};

const MENU_ALL_SENSORS = {
    'en': ["Slider", "Light", "Sound", "Button", "A", "B", "C", "D"],
    'zh-tw': ["滑桿", "光線", "聲音", "按鈕", "A", "B", "C", "D"],
    'zh-cn': ["滑杆", "光线", "声音", "按钮", "A", "B", "C", "D"],
    'pt-br': ["Controle deslizante", "Luz", "Som", "Botão", "A", "B", "C", "D"],
    'pt': ["Controle deslizante", "Luz", "Som", "Botão", "A", "B", "C", "D"],
    'fr': ["Glissière", "Lumière", "Son", "Bouton", "A", "B", "C", "D"],
    'pl': ["Suwak", "Światło", "Dźwięk", "Przycisk", "A", "B", "C", "D"],
};

const MENU_COMPARISONS = {
    'en': ['>', '<'],
    'zh-tw': ['>', '<'],
    'zh-cn': ['>', '<'],
    'pt-br': ['>', '<'],
    'pt': ['>', '<'],
    'fr': ['>', '<'],
    'pl': ['>', '<'],
};

const MENU_BUTTON_STATES = {
    'en': ["pressed", "released"],
    'zh-tw': ["被按下", "被放開"],
    'zh-cn': ["被按下", "被放开"],
    'pt-br': ["pressionado", "liberado"],
    'pt': ["pressionado", "liberado"],
    'fr': ["appuyé", "relaché"],
    'pl': ["wciśnięty", "zwolniony"],
};

const FormBetween = {
    'en': 'When [SENSOR] value is between [LOW] and [HIGH]',
    'zh-tw': '當 [SENSOR] 的偵測值介於 [LOW] 與 [HIGH] 之間',
    'zh-cn': '当 [SENSOR] 的侦测值介于 [LOW] 与 [HIGH] 之间',
    'pt-br': 'Quando [SENSOR] estiver entre [LOW] e [HIGH]',
    'pt': 'Quando [SENSOR] estiver entre [LOW] e [HIGH]',
    'fr': 'Si la valeur de [SENSOR] est entre [LOW] et [HIGH]',
    'pl': 'Kiedy wartość [SENSOR] jest pomiędzy [LOW] i [HIGH]',
};

const FormComparison = {
    'en': 'When [SENSOR] [COMP] [VALUE].',
    'zh-tw': '當 [SENSOR] 的偵測值 [COMP] [VALUE]',
    'zh-cn': '当 [SENSOR] 的侦测值 [COMP] [VALUE]',
    'pt-br': 'Quando [SENSOR] for [COMP] que [VALUE]',
    'pt': 'Quando [SENSOR] for [COMP] que [VALUE]',
    'fr': 'si [SENSOR] [COMP] [VALUE].',
    'pl': 'Kiedy [SENSOR] [COMP] [VALUE].',
};

const FormButton = {
    'en': 'When Button [STATE].',
    'zh-tw': '當按鈕 [STATE]',
    'zh-cn': '当按钮 [STATE]',
    'pt-br': 'Quando o botão estiver [STATE].',
    'pt': 'Quando o botão estiver [STATE].',
    'fr': 'Si Bouton [STATE].',
    'pl': 'Kiedy przycisk jest [STATE].',
};

const FormIsButtonPressed = {
    'en': 'Is Button Pressed?',
    'zh-tw': '按鈕被按下？',
    'zh-cn': '按钮被按下？',
    'pt-br': 'O botão está pressionado?',
    'pt': 'O botão está pressionado?',
    'fr': 'Bouton appuyé ?',
    'pl': 'Czy przycisk jest wciśnięty?',
};

const FormIsSensorComparison = {
    'en': 'Is [SENSOR] [COMP] [VALUE] ?',
    'zh-tw': '[SENSOR] 的偵測值 [COMP] [VALUE] ？',
    'zh-cn': '[SENSOR] 的侦测值 [COMP] [VALUE] ？',
    'pt-br': '[SENSOR] está [COMP] [VALUE] ?',
    'pt': '[SENSOR] está [COMP] [VALUE] ?',
    'fr': 'Est-ce que [SENSOR] [COMP] [VALUE] ?',
    'pl': 'Czy [SENSOR] [COMP] [VALUE] ?',
};

const FormCurrentSensorValue = {
    'en': '[SENSOR] current value.',
    'zh-tw': '[SENSOR] 的偵測值',
    'zh-cn': '[SENSOR] 的侦测值',
    'pt': 'Ler valor atual: [SENSOR]',
    'pt-br': 'Ler valor atual: [SENSOR]',
    'fr': 'valeur actuelle de [SENSOR].',
    'pl': 'Aktualna wartość [SENSOR].',
};

const FormRangeConverter = {
    'en': 'Convert [SENSOR] value to a range of [RANGE1] to [RANGE2]',
    'zh-tw': '轉換 [SENSOR] 的偵測值到 [RANGE1] 與 [RANGE2] 之間',
    'zh-cn': '转换 [SENSOR] 的侦测值到 [RANGE1] 与 [RANGE2] 之间',
    'pt-br': 'Converte valor: [SENSOR] para que fique entre [RANGE1] e [RANGE2]',
    'pt': 'Converte valor: [SENSOR] para que fique entre [RANGE1] e [RANGE2]',
    'fr': 'Convertir la valeur de [SENSOR] dans la plage [RANGE1] à [RANGE2]',
    'pl': 'Przelicz wartość [SENSOR] do zakresu od [RANGE1] do [RANGE2]',
};

class Scratch3PicoboardOneGPIO {
    constructor(runtime) {
        the_locale = this._setLocale();
        this.runtime = runtime;
    }

    getInfo() {
        the_locale = this._setLocale();
        // connect to the websocket server
        this.connect();

        return {
            id: 'onegpioPicoboard',
            color1: '#0C5986',
            color2: '#34B0F7',
            name: 'OneGpio Picoboard',
            blockIconURI: 'data:image/png;base64,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',
            blocks: [
                {
                    opcode: 'sensor_comparison',
                    blockType: BlockType.HAT,
                    text: FormComparison[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        COMP: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_COMPARISONS[the_locale][0],
                            menu: 'comparisons'
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50,
                        }
                    }
                },
                {
                    opcode: 'button_change',
                    blockType: BlockType.HAT,
                    text: FormButton[the_locale],
                    arguments: {
                        STATE: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_BUTTON_STATES[the_locale][0],
                            menu: 'button_states'
                        }
                    }
                },
                {
                    opcode: 'sensor_between',
                    blockType: BlockType.HAT,
                    text: FormBetween[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        LOW: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 25,
                        },
                        HIGH: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 75,
                        }
                    }
                },
                {
                    opcode: 'is_button_pressed',
                    blockType: BlockType.BOOLEAN,
                    text: FormIsButtonPressed[the_locale],
                },
                {
                    opcode: 'is_sensor',
                    blockType: BlockType.BOOLEAN,
                    text: FormIsSensorComparison[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        COMP: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_COMPARISONS[the_locale][0],
                            menu: 'comparisons'
                        },
                        VALUE: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 50,
                        }
                    }
                },
                {
                    opcode: 'current_sensor_value',
                    blockType: BlockType.REPORTER,
                    text: FormCurrentSensorValue[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_ALL_SENSORS[the_locale][0],
                            menu: 'all_sensors'
                        }
                    }
                },
                {
                    opcode: 'range_convert',
                    blockType: BlockType.REPORTER,
                    text: FormRangeConverter[the_locale],
                    arguments: {
                        SENSOR: {
                            type: ArgumentType.STRING,
                            defaultValue: MENU_NON_BUTTON_SENSORS[the_locale][0],
                            menu: 'non_button_sensors'
                        },
                        RANGE1: {
                            type: ArgumentType.NUMBER,
                            defaultValue: -240,
                        },
                        RANGE2: {
                            type: ArgumentType.NUMBER,
                            defaultValue: 240,
                        }
                    }
                },
            ],
            menus: {
                all_sensors: 'getAllSensorMenuItems',
                //non_button_sensors: MENU_NON_BUTTON_SENSORS[the_locale],
                non_button_sensors: 'getAllNonButtonMenuItems',
                //button_states: MENU_BUTTON_STATES[the_locale],
                button_states: 'get_button_states',

                //all_sensors: MENU_ALL_SENSORS[the_locale],

                comparisons: MENU_COMPARISONS[the_locale],
            }
        };
    }

    getAllSensorMenuItems() {
        return MENU_ALL_SENSORS[the_locale];
    }

    getAllNonButtonMenuItems() {
        return MENU_NON_BUTTON_SENSORS[the_locale];
    }

    get_button_states() {
        return MENU_BUTTON_STATES[the_locale];
    }

    mapAllSensors(device) {
        //["Slider", "Light", "Sound", "Button", "A", "B", "C", "D"]
        /*
        data value 0 = D  analog inverted logic
        data value 1 = C  analog inverted logic
        data value 2 = B  analog inverted logic
        data value 3 = Button  digital inverted logic
        data value 4 = A  analog inverted logic
        data value 5 = Light  analog inverted logic
        data value 6 = sound  analog
        data value 7 = slider analog
         */
        //let theAllSensorMap = {0: 7, 1: 5, 2: 6, 3: 3, 4: 4, 5: 2, 6: 1, 7:0 }
        return theAllSensorMap[device];
    }

    mapNonButtonSensors(device) {
        //["Slider", "Light", "Sound", "A", "B", "C", "D"]
        return theNonButtonSensorMap[device];

    }

    // The block handlers

    sensor_between(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.sensor_between.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];
            let low = parseInt(args['LOW'], 10);
            let high = parseInt(args['HIGH'], 10);
            return value >= low && value <= high;
        }
    }

    sensor_comparison(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.sensor_comparison.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];
            let comp_type = args['COMP'];
            let comp_value = parseInt(args['VALUE'], 10);
            if (comp_type === '<') {
                return value < comp_value;
            } else {
                return value > comp_value;
            }
        }

    }

    button_change(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.button_change.bind(this), args];
            wait_open.push(callbackEntry);
        } else {

            let item_index = this.get_button_states().indexOf(args['STATE']);
            // testing for pressed
            if (item_index === 0) {
                return lastDataSample[3] === 1;
            } else {
                return lastDataSample[3] === 0;
            }
        }
    }

    is_button_pressed(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.is_button_pressed.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get current button value
            return Boolean(Number(lastDataSample[3]));

        }

    }

    is_sensor(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.is_sensor.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];
            let comp_type = args['COMP'];
            let comp_value = parseInt(args['VALUE'], 10);
            if (comp_type === '<') {
                return value < comp_value;
            } else {
                return value > comp_value;
            }
        }

    }

    current_sensor_value(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.current_sensor_value.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get the text of the menu item
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllSensorMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapAllSensors(item_index);
            // retrieve the data from the last data sample
            return lastDataSample[map_key];
        }

    }

    range_convert(args) {
        if (!connected) {
            if (!connection_pending) {
                this.connect();
                connection_pending = true;
            }
        }

        if (!connected) {
            let callbackEntry = [this.range_convert.bind(this), args];
            wait_open.push(callbackEntry);
        } else {
            // get the text of the menu item
            let sensor_text = args['SENSOR'];
            // get its index in the list of menu items
            let item_index = this.getAllNonButtonMenuItems().indexOf(sensor_text);
            // using the item_index, lookup the index into the
            // last data values to retrieve current data value for the sensor
            let map_key = this.mapNonButtonSensors(item_index);
            // get current value of sensor
            let value = lastDataSample[map_key];

            let high = parseInt(args['RANGE2'], 10);
            let low = parseInt(args['RANGE1'], 10);
            return Math.round(((value) * ((high - low) / 100)) +
                low);
        }

    }

    // end of block handlers

    _setLocale() {
        let now_locale = '';
        switch (formatMessage.setup().locale) {
            case 'zh-tw':
                now_locale = 'zh-tw';
                break;
            case 'zh-cn':
                now_locale = 'zh-cn';
                break;
            case 'en':
                now_locale = 'en';
                break;
            case 'pt-br':
                now_locale = 'pt-br';
                break;
            case 'pt':
                now_locale = 'pt';
                break;
            case 'fr':
                now_locale = 'fr';
                break;
            case 'pl':
                now_locale = 'pl';
                break;
            default:
                now_locale = 'en';
                break;
        }
        return now_locale;
    }

    // helpers
    connect() {
        if (connected) {
            // ignore additional connection attempts
            return;
        } else {
            connect_attempt = true;
            window.socket = new WebSocket("ws://127.0.0.1:9004");
            msg = JSON.stringify({"id": "to_picoboard_gateway"});
        }


        // websocket event handlers
        window.socket.onopen = function () {
            // connection complete
            connected = true;
            connect_attempt = true;
            // the message is built above
            try {
                //ws.send(msg);
                window.socket.send(msg);

            } catch (err) {
                // ignore this exception
            }
            for (let index = 0; index < wait_open.length; index++) {
                let data = wait_open[index];
                data[0](data[1]);
            }
        };

        window.socket.onclose = function () {
            if (alerted === false) {
                alerted = true;
                alert(FormWSClosed[the_locale]);}
            connected = false;
        };

        // reporter messages from the board
        window.socket.onmessage = function (message) {
            // store the latest incoming data
            msg = JSON.parse(message.data);
            // let report_type = msg["report"];
            lastDataSample = msg['report'];
        };
    }
}

module
    .exports = Scratch3PicoboardOneGPIO;
